/*
* app.js - simple express server with middleware
*/

/*jslint         node    : true, continue : true,
  devel  : true, indent  : 2,    maxerr   : 50,
  newcap : true, nomen   : true, plusplus : true,
  regexp : true, sloppy  : true, vars     : false,
  white  : true
*/

/*global */

//{{Module Scope Variables
var
	http 	= require('http'),
	fs 		= require('fs'),
	express = require('express'),
	app 	= express(),
	server 	= http.createServer(app);
//Module Scope Variables}}

var book = {
	chp_1: {	
	sec_1: String() + "<h3 id=\"sec_1\">Macros</h3>\n<p><i>Lisp's core occupies some kind of local optimum in the space of programming languages.\n\n&mdash;Modest words from John McCarthy, inventor of lisp</i></p><p>This is a book about programming <i>macros</i> in lisp. Unlike most programming books that only give them a cursory overview, this book is a series of tutorials and examples designed to get you programming sophisticated macros as efficiently and quickly as possible. Mastering macros is the final step to graduating from an intermediate lisp programmer to a lisp professional.</p><p>Macros are the single greatest advantage that lisp has as a programming language and the single greatest advantage of any programming language. With them you can do things that you simply cannot do in other languages. Because macros can be used to transform lisp into other programming languages and back, programmers who gain experience with them discover that all other languages are just skins on top of lisp. This is the <i>big deal</i>. Lisp is special because programming with it is actually programing at a higher level. Where most languages invent and enforce syntactic and semantic rules, lisp is general and malleable. With lisp, you make the rules.</p><p>Lisp has a richer, deeper history than all other programming languages. Some of the best and brightest computer scientists throughout our field's brief existence have worked very hard to make it the most powerful and general programming language ever. Lisp also enjoys a number of concise standards, multiple excellent open-source implementations, and more macro conveniences than any other programming language. This book uses only C<small>OMMON</small> L<small>ISP</small><sup><small>[ANSI-CL]</small></sup><sup><small>[CLTL2]</small></sup> but many of the ideas are trivially portable to other lisps like Scheme<sup><small>[R5RS]</small></sup>. That said, hopefully this book will convince you that if you want to write macros, C<small>OMMON</small> L<small>ISP</small> is the lisp to use. While different types of lisp are excellent for other purposes, C<small>OMMON</small> L<small>ISP</small> is deservedly the tool of choice for the macro professional.</p><p>The designers of C<small>OMMON</small> L<small>ISP</small> have done an excellent job in designing a programming language <i>right</i>. Especially after considering implementation quality, C<small>OMMON</small> L<small>ISP</small> is, with surprisingly few reservations, by far the best programming environment available to current-day programmers. As a programmer you can almost always count on C<small>OMMON</small> L<small>ISP</small> to have done it the way it ought be done. While it's true the designers and implementors have done it the right way, some feel that they forgot to describe to us just why it's right. To many outsiders C<small>OMMON</small> L<small>ISP</small> just looks like an enormous collection of strange features, and so are turned off, moving to a more immediately gratifying language&mdash;doomed to never experience the true power of macros. Although it is not its primary purpose, this book can be used as a tour of many of the best features in the amazing language that is C<small>OMMON</small> L<small>ISP</small>. Most languages are designed to be easy to implement; C<small>OMMON</small> L<small>ISP</small> is designed to be powerful to program. I sincerely hope the creators of C<small>OMMON</small> L<small>ISP</small> appreciate this book as one of the most complete and accessible treatments of the language's advanced macro features, and also as an enjoyable drop in the ocean of topics that is the macro.</p><p>Macros have, not by accident, almost as much history as lisp itself, being invented in 1963 by Timothy Hart<sup><small>[MACRO-DEFINITIONS]</small></sup>. However, macros are still not used to the fullest possible extent by most lisp programmers and are not used at all by all other programmers. This has always been a conundrum for advanced lispers. Since macros are so great, why doesn't everybody use them all the time? While it's true that the smartest, most determined programmers always end up at lisp macros, few start their programming careers there. Understanding why macros are so great requires understanding what lisp has that other languages don't. It requires an understanding of other, less powerful languages. Sadly, most programmers lose the will to learn after they have mastered a few other languages and never make it close to understanding what a macro is or how to take advantage of one. But the top percentile of programmers in any language are always forced to learn some sort of way to write programs that write programs: macros. Because it is the best language for writing macros, the smartest and most determined and most curious programmers always end up at lisp.</p><p>Although the top-percentile of programmers is necessarily a small number, as the overall programming population grows so does the number of top-percentile programmers. The programming world sees few examples of the power of macros and understands far fewer, but this is changing. Because of the productivity multiplication that can be achieved through macros, the <i>age of the macro</i> is coming, whether the world is ready or not. This book aims to be a base-line preparation for the inevitable future: a world of macros. Be prepared.</p><p>The conventional wisdom surrounding macros is to use them only when necessary because they can be difficult to understand, contain extremely subtle bugs, and limit you in possibly surprising ways if you think of everything as functions. These aren't defects in the lisp macro system itself but instead are traits of macro programming in general. As with any technology, the more powerful the tool, the more ways there are to misuse it. And, as far as programming constructs go, lisp macros are the most powerful tool.</p><p>An interesting parallel to learning macros in lisp is that of learning pointers in the C programming language. Most beginning C programmers are able to quickly pick up most of the language. Functions, types, variables, arithmetic expressions: all have parallels in previous intellectual experiences beginners might have had, from elementary school maths to experimenting with simpler programming languages. But most novice C programmers hit a brick wall when they encounter pointers.</p><p>Pointers are second nature to experienced C programmers, most of whom consider their complete understanding necessary for the proper use of C. Because pointers are so fundamental, most experienced C programmers would not advise limits on their use for stylistic or learning purposes. Despite this, many C novices feel pointers are an unnecessary complication and avoid their use, resulting in the <i>FORTRAN in any language</i> symptom where valuable language features are neglected. The disease is ignorance of the language's features, not poor programming style. Once the features are fully understood, the correct styles are obvious. An auxiliary theme of this book, one that applies to any programming language, is that in programming, style is not something to pursue directly. Style is necessary only where understanding is missing<a href=\"#\" onclick=\"toggle_note(1); return false\"><sup>1</sup></a><span id=\"note_1\" style=\"display:none\"> <sup><i>A corollary to this is that sometimes the only way to effectively use something you don't understand is to copy styles observed elsewhere.</i></sup> </span>.</p><p>Like C pointers, the macro is a feature of lisp that is often poorly understood, the wisdom on its proper use being very distributed and idealised. If when considering macros you find yourself relying on stylistic aphorisms like</p><p><i>Macros change the syntax of lisp code.</i></p><p><i>Macros work on the parse tree of your program.</i></p><p><i>Only use macros when a function won't do.</i></p><p>you are probably missing the big picture when it comes to macro programming. That is what this book hopes to fix.</p><p>There are very few good references or tutorials on macro construction. Paul Graham's <i>On Lisp</i><sup><small>[ON-LISP]</small></sup> is one of the exceptions. Every word of <i>On Lisp</i> is required reading for anyone interested in macros. <i>On Lisp</i> and Graham's other writings were the most important inspirations for the creation of the book you are reading now. Thanks to Paul Graham and other lisp writers, the power that macros provide programmers is widely discussed, yet is unfortunately still widely misunderstood. Despite the wisdom regarding macro programming that can be gleaned from a simple perusal of <i>On Lisp</i>, few programmers make the connection between the macro and their real-life programming problems. While <i>On Lisp</i> will show you the different types of macros, this book will show you how to use them.</p><p>Macro writing is a reflective and iterative process. All complex macros come from simpler macros, often through a long series of improvement-test cycles. What's more, recognising where to apply macros is an acquired skill that comes directly from writing them. When you write a program, you, as a conscious human, are following a system and a process whether you are aware of it or not. Every programmer has a conceptual model of how programming tools work and the creation of code comes as a direct, logical result of this. Once an intelligent programmer begins to think of the act of programming as a logical procedure, the logical next step is for this process to benefit from automation itself. After all, programmers are trained to do exactly this: automate processes.</p><p>The crucial first step to understanding macros is to recognise that without careful planning and lots of effort, large portions of any programs will have redundant patterns and inflexible abstractions littered throughout. This can be seen in almost any large software project as duplicated code or as code that is needlessly complex because the right abstractions weren't available to its authors. The effective use of macros entails recognising these patterns and abstractions, and then creating <i>code to help you code</i>. It is not enough to understand how to write macros; a professional lisp programmer needs to know why to write macros.</p><p>C programmers who are new to lisp often make the mistake of assuming that the primary purpose of a macro is to improve the efficiency of code at run-time<a href=\"#\" onclick=\"toggle_note(2); return false\"><sup>2</sup></a><span id=\"note_2\" style=\"display:none\"> <sup><i>C programmers make this mistake because they are used to a \"macro system\" that is good for little else.</i></sup> </span>. While macros are often very useful for this task, by far the most common use of a macro is to make the job of programming a desired application easier. Because large portions of the patterns in most programs are redundantly copied and the generality of their abstractions not fully exploited, properly designed macros can enable programming on literally new planes of expression. Where other languages are rigid and specific, lisp is fluid and generic.</p><p>This book is not an introduction to lisp. The topics and material are aimed at professional programmers of non-lisp languages who are curious as to what macros have to offer, and at intermediate lisp students who are ready to really learn what makes lisp special. Basic to intermediate knowledge of lisp programming is assumed, but a deep understanding of closures and macros is not.</p><p>This book is also not about theory. All examples involve working, usable code that can help improve your programming, today and now. This book is about using advanced programming techniques to help you program better. In contrast to many other programming books that deliberately use a simple programming style in an attempt to improve accessibility, this book takes the view that the best approach to teaching programming is full utilisation of the language. Although many of the provided code samples use esoteric features of C<small>OMMON</small> L<small>ISP</small>, such potentially unfamiliar features are described as they are used. For calibration, if you have read and understood<a href=\"#\" onclick=\"toggle_note(3); return false\"><sup>3</sup></a><span id=\"note_3\" style=\"display:none\"> <sup><i>Not necessarily agreed with, of course.</i></sup> </span> everything in <a href=\"chap2.html\">chapter 2, Closures</a> and <a href=\"chap3.html\">chapter 3, Macro Basics</a>, for the purposes of this book you can consider yourself past the intermediate stage of lisp understanding.</p><p>Part of lisp is discovering things yourself and this book will not deprive you of that. Be warned that this book moves more quickly than most, more quickly than you might be used to. To understand some of the code in this book you may need to consult additional C<small>OMMON</small> L<small>ISP</small> tutorials or references. After we cover the basics we will move directly into explaining some of the most advanced macro research to-date, much of which borders a large, unexplored gray-area of intellectual terrain. As does all advanced macro programming, this book focuses heavily on <i>combinations</i> of macros. This topic has a frightening reputation and is well understood by few, if any, programmers. Combinations of macros represent the most vast and fertile area of research in programming languages today. Academia has squeezed out most of the interesting results from types, objects, and prolog-style logic, but macro programming remains a huge, gaping black hole. Nobody really knows what lies beyond. All we know is that, yes, it is complicated and frightening and currently appears boundless in potential. Unlike too many other programming ideas, the macro is neither an academic concept for churning out useless theoretical publications, nor an empty enterprise software buzzword. Macros are a hacker's best friend. Macros let you program smarter, not harder. Most programmers who come to understand macros decide they never again want to program without them.</p><p>While most lisp books are written to make lisp more popular, I am completely unconcerned with lisp's day-to-day public appeal. Lisp isn't going away. I would be perfectly happy if I could continue to use lisp as a <i>secret weapon</i> for the remainder of my programming career. If this book has only one purpose, it is to inspire the study and research of macros, just as I have been inspired by them in <i>On Lisp</i>. I hope readers of this book might also be so inspired that some day I might enjoy even better lisp macro tools and even more interesting lisp macro books.</p><p>Still in awe of lisp's power,</p><p>your humble author,</p><p>Doug Hoyte</p>",
	sec_2: String() + "<h3 id=\"sec_2\">U-Language</h3>\n<p>Since discussing macros involves discussing discussion itself, we need to be very clear about the conventions we are adopting for this book. What I am writing right now, as conveyed to you by what you are reading and interpreting, is itself a system of expression worth formalising and analysing.</p><p>Nobody has understood this better than Haskell Curry, the author of <i>Foundations Of Mathematical Logic</i><sup><small>[FOUNDATIONS]</small></sup>. Curry, because he was not only trying to formalise ideas, but also the very expression of ideas, found it necessary to abstract this concept of a communicative language between writer and reader. He called it the U-Language.</p><p><i>Every investigation, including the present one, has to be communicated from one person to another by means of language. It is expedient to begin our study by calling attention to this obvious fact, by giving a name to the language being used, and by being explicit about a few of its features. We shall call the language being used the U-Language. [...] There would be no point in calling attention to it, if it were not for the fact that language is more intimately related to our job than of most others.</i></p><p>Throughout this book we will introduce key new concepts or points that otherwise deserve emphasis in <i>this special font</i>. When referencing special forms, functions, macros, and other identifiers found in a program, either presented or foreign, we will use <b>this special font</b> (notice that some words have multiple meanings, for example <b>lambda</b> the C<small>OMMON</small> L<small>ISP</small> macro versus lambda the concept; <b>let</b> the special form versus a list that is a let form).</p><p><fieldset><legend>EXAMPLE-PROGRAM-LISTING</legend><pre class=\"lol_code\">(defun example-program-listing ()\n  '(this is\n     (a (program\n          (listing)))))</pre></fieldset></p><p>In this book new pieces of code are introduced in the form of <i>program listings</i>. Code that is designed for re-use, or for an example of proper implementation, is presented as in the definition of our function <b>example-program-listing</b>. But sometimes we wish to demonstrate the use of a bit of code or just want to discuss properties of some expressions without departing the flow of the written text<a href=\"#\" onclick=\"toggle_note(4); return false\"><sup>4</sup></a><span id=\"note_4\" style=\"display:none\"> <sup><i>And this is a foot-note, a relevant but concise departure from the main text.</i></sup> </span>. In those cases, the code, or example uses of the code, will appear like so:</p><p><pre class=\"lol_pre\">(this is\n  (demonstration code))</pre></p><p>Much writing that teaches programming makes heavy use of isolated, contrived examples to illustrate a point but forgets to tie it in with reality. This book's examples try to be as minimal and direct as possible in order to illustrate the big-picture programming ideas currently being explained. Some writing tries to hide being boring by using cute, quirky identifier names or skin-deep analogies in its examples. Our examples serve only to illustrate ideas. That said, above all this book tries not to take itself (or anything) too seriously. There is humour here, the difference is that you need to look for it.</p><p>Because of lisp's interactive nature, the results of evaluating a simple expression can often convey more than the equivalent quantity of U-Language. In such cases, this is how we will show the output from a C<small>OMMON</small> L<small>ISP</small> Read Evaluate Print Loop (called the <i>REPL</i>):</p><p><pre class=\"lol_pre\">* (this is\n    (the expression\n      (to evaluate)))\n\nTHIS-IS-THE-RESULT</pre></p><p>Notice how the text we enter is in lower-case but the text returned from lisp is in upper-case. This is a feature of C<small>OMMON</small> L<small>ISP</small> that allows us to easily scan a REPL print-out and know which expressions we entered versus which were printed out by lisp. More precisely, this feature lets us quickly scan any lisp form that contains symbols&mdash;in any file or on any screen&mdash;and instantly know whether it has yet been processed by the lisp reader. Also notice that the asterisk character (<b>*</b>) represents a prompt. This character is ideal because it can't be confused with a balanced character and because of its high pixel count that makes it stand out clearly when scanning a REPL session.</p><p>Writing complicated lisp macros is an <i>iterative</i> process. Nobody sits down and hammers out a page-long macro in the cavalier style common to programs in other languages. This is partly because lisp code contains much more information per page than most other languages and also partly because lisp technique encourages programmers to grow their programs: refining them in a series of enhancements dictated by the needs of the application.</p><p>This book distinguishes types of lisp, like C<small>OMMON</small> L<small>ISP</small> and Scheme, from the more abstract notion of lisp the building material. Another important distinction is made between lisp programming languages and non-lisp programming languages. Sometimes we need to talk about non-lisp languages and, to make as few enemies as possible, would like to avoid picking on any language in particular. To do so, we resort to the following unusual definition:</p><p><i>A language without lisp macros is a <i>Blub</i>.</i></p><p>The U-language word Blub comes from an essay by Paul Graham, <i>Beating the Averages</i><sup><small>[BEATING-AVGS]</small></sup>, where Blub is a hypothetical language used to highlight the fact that lisp is not like other languages: lisp is different. Blub is characterised by infix syntax, annoying type systems, and crippled object systems but its only unifying trait is its lack of lisp macros. Blub terminology is useful to us because sometimes the easiest way to understand an advanced macro technique is to consider why the technique is impossible in Blub. The purpose of Blub terminology is not to poke fun at non-lisp languages<a href=\"#\" onclick=\"toggle_note(5); return false\"><sup>5</sup></a><span id=\"note_5\" style=\"display:none\"> <sup><i>There will be a little bit of fun.</i></sup> </span>.</p><p><fieldset><legend>ITERATIVE-PROCESS-EXAMPLE</legend><pre class=\"lol_code\">(defun example-function% () ; first try\n  t)\n\n(defun example-function%% () ; second try\n  t)\n\n(defun example-function () ; got it!\n  t)</pre></fieldset></p><p>In order to illustrate the iterative process of macro creation, this book adopts the convention where the percent (%) character is appended to the names of functions and macros whose definitions are incomplete or are yet to be improved upon in some other way. Multiple revisions can result in multiple % characters on the end of a name before we settle on the final version with no % characters.</p><p>Macros are described in Curry's terminology as <i>meta-programming</i>. A meta-program is a program with the sole purpose of enabling a programmer to better write programs. Although meta-programming is adopted to various extents in all programming languages, no language adopts it as completely as lisp. In no other language is the programmer required to write code in such a way to convenience meta-programming techniques. This is why lisp programs look <i>weird</i> to non-lisp programmers: how lisp code is expressed is a direct consequence of its meta-programming needs. As this book attempts to describe, this design decision of lisp&mdash;writing meta-programs in lisp itself&mdash;is what gives lisp the stunning productivity advantages that it does. However, because we create meta-programs in lisp, we must keep in mind that meta programming is different from U-Language specification. We can discuss meta-languages from different perspectives, including other meta-languages, but there is only one U-Language. Curry makes this clear for his system as well:</p><p><i>We can continue to form hierarchies of languages with any number of levels. However, no matter how many levels there are, the U-Language will be the highest level: if there are two levels, it will be the meta-language; if there are three levels, it will be the meta-meta-language; and so on. Thus the terms U-Language and meta-language must be kept distinct.</i></p><p>This is a book about lisp, of course, and lisp's logic system is very different than that described by Curry so we will adopt few other conventions from his work. But Curry's contributions to logic and meta-programming continue to inspire us to this day. Not only because of his profound insights regarding symbolic quotation, but also his beautifully phrased and executed U-Language.",
	sec_3: String() + "</p><h3 id=\"sec_3\">The Lisp Utility</h3>\n<p><i>On Lisp</i> is one of those books that you either understand or you don't understand. You either adore it or you fear it. Starting with its very title, <i>On Lisp</i> is about creating programming abstractions which are layers <i>on top of lisp</i>. After we've created these abstractions we are free to create more programming abstractions which are successive layers on earlier abstractions.</p><p>In almost any language worth using, large portions of the language's functionality is implemented with the language itself; Blub languages usually have extensive standard libraries written in Blub. When even implementors don't want to program in the target language, you probably won't want to either.</p><p>But even after considering the standard libraries of other languages, lisp is different. In the sense that other languages are composed of primitives, lisp is composed of meta-primitives. Once macros are standardised, as in C<small>OMMON</small> L<small>ISP</small>, the rest of the language can be <i>boot-strapped</i> up from essentially nothing. While most languages just try to give a flexible enough set of these primitives, lisp gives a meta-programming system that allows any and all sorts of primitives. Another way to think about it is that lisp does away with the concept of primitives altogether. In lisp, the meta-programming system doesn't stop at any so-called primitives. It is possible, in fact desired, for these macro programming techniques used to build the language to continue on up into the user application. Even applications written by the highest-level of users are still macro layers on the lisp onion, growing through iterations.</p><p>In this light, there being primitives in a language at all is a problem. Any time there is a primitive, there is a barrier, a non-orthogonality, in the design of the system. Sometimes, of course, this is warranted. Most programmers have no problem treating individual machine code instructions as primitives for their C or lisp compilers to handle. But lisp users demand control over nearly everything else. No other languages are, with respect to the control given to the programmer, as complete as lisp.</p><p>Heeding the advice of <i>On Lisp</i>, the book you are currently reading was itself designed as another layer on the onion. In the same sense that programs are layered on other programs, this book is layered on <i>On Lisp</i>. It is the central theme of Graham's book: well-designed <i>utilities</i> can, when combined, work together to give a greater than the sum of the parts productivity advantage. This section describes a collection of useful utilities from <i>On Lisp</i> and elsewhere.</p><p><fieldset><legend>MKSTR-SYMB</legend><pre class=\"lol_code\">(defun mkstr (&amp;rest args)\n  (with-output-to-string (s)\n    (dolist (a args) (princ a s))))\n\n(defun symb (&amp;rest args)\n  (values (intern (apply #'mkstr args))))</pre></fieldset></p><p><b>Symb</b>, layered upon <b>mkstr</b>, is a general way of creating symbols. Since symbols can be referenced by any arbitrary string, and creating symbols programmatically is so useful, <b>symb</b> is an essential utility for macro programming and is used heavily throughout this book.</p><p><fieldset><legend>GROUP</legend><pre class=\"lol_code\">(defun group (source n)\n  (if (zerop n) (error \"zero length\"))\n  (labels ((rec (source acc)\n             (let ((rest (nthcdr n source)))\n               (if (consp rest)\n                   (rec rest (cons\n                               (subseq source 0 n)\n                               acc))\n                   (nreverse\n                     (cons source acc))))))\n    (if source (rec source nil) nil)))</pre></fieldset></p><p><b>Group</b> is another utility that consistently pops up when writing macros. Part of this is because of the need to mirror operators like C<small>OMMON</small> L<small>ISP</small>'s <b>setf</b> and <b>psetf</b> that already group arguments, and part of it is because grouping is often the best way to structure related data. Since we use this functionality so often, it makes sense to make the abstraction as general as possible. Graham's <b>group</b> will group by any provided grouping amount, specified by the parameter <b>n</b>. In cases like <b>setf</b>, where the arguments are grouped into pairs, <b>n</b> is 2.</p><p><fieldset><legend>FLATTEN</legend><pre class=\"lol_code\">(defun flatten (x)\n  (labels ((rec (x acc)\n             (cond ((null x) acc)\n                   ((atom x) (cons x acc))\n                   (t (rec\n                        (car x)\n                        (rec (cdr x) acc))))))\n    (rec x nil)))</pre></fieldset></p><p><b>Flatten</b> is one of the most important utilities in <i>On Lisp</i>. Given an arbitrarily nested list structure, <b>flatten</b> will return a new list containing all the atoms reachable through that list structure. If we think of the list structure as being a tree, <b>flatten</b> will return a list of all the leaves in the tree. If that tree represents lisp code, by checking for the presence of certain objects in an expression, <b>flatten</b> accomplishes a sort of <i>code-walking</i>, a recurring theme throughout this book.</p><p><fieldset><legend>FACT-AND-CHOOSE</legend><pre class=\"lol_code\">(defun fact (x)\n  (if (= x 0)\n    1\n    (* x (fact (- x 1)))))\n\n(defun choose (n r)\n  (/ (fact n)\n     (fact (- n r))\n     (fact r)))</pre></fieldset></p><p><b>Fact</b> and <b>choose</b> are the obvious implementations of the factorial and binomial coefficient functions.</p>",
	sec_4: String() + "<h3 id=\"sec_4\">License</h3>\n<p>Because I believe the concepts behind the code presented in this book are as fundamental as physical observations or mathematical proofs, even if I wanted to I don't believe I could claim their ownership. For that reason you are basically free to do whatever you want with the code from this book. Here is the very liberal license distributed with the code:</p><p><pre class=\"lol_pre\">;; This is the source code for the book\n;; _Let_Over_Lambda_ by Doug Hoyte.\n;; This code is (C) 2002-2008, Doug Hoyte.\n;;\n;; You are free to use, modify, and re-distribute\n;; this code however you want, except that any\n;; modifications must be clearly indicated before\n;; re-distribution. There is no warranty,\n;; expressed nor implied.\n;;\n;; Attribution of this code to me, Doug Hoyte, is\n;; appreciated but not necessary. If you find the\n;; code useful, or would like documentation,\n;; please consider buying the book!</pre></p><p>The text of this book is (C) 2008 Doug Hoyte. All rights reserved.</p>",
	sec_5: String() + "<h3 id=\"sec_5\">Thanks</h3>\n<p>Brian Hoyte, Nancy Holmes, Rosalie Holmes, Ian, Alex, all the rest of my family; syke, madness, fyodor, cyb0rg/asm, theclone, blackheart, d00tz, rt, magma, nummish, zhivago, defrost; Mike Conroy, Sylvia Russell, Alan Paeth, Rob McArthur, Sylvie Desjardins, John McCarthy, Paul Graham, Donald Knuth, Leo Brodie, Bruce Schneier, Richard Stallman, Edi Weitz, Peter Norvig, Peter Seibel, Christian Queinnec, Keith Bostic, John Gamble; the designers and creators of C<small>OMMON</small> L<small>ISP</small>, especially Guy Steele, Richard Gabriel, and Kent Pitman, the developers and maintainers of CMUCL/SBCL, CLISP, OpenBSD, GNU/Linux.</p><p>Special thanks to Ian Hoyte for the cover design and Leo Brodie for the back-cover cartoon.</p><p>This book is dedicated to everyone who loves programming.</p>"
	},

	chp_2: {
	sec_1: String() + "<h3 id=\"sec_1\">Closure-Oriented Programming</h3>\n<p><i>One of the conclusions that we reached was that the \"object\" need not be a primitive notion in a programming language; one can build objects and their behaviour from little more than assignable value cells and good old lambda expressions.\n\n&mdash;Guy Steele on the design of Scheme</i></p><p>Sometimes it's called a <i>closure</i>, other times a saved lexical environment. Or, as some of us like to say, <i>let over lambda</i>. Whatever terminology you use, mastering this concept of a closure is the first step to becoming a professional lisp programmer. In fact, this skill is vital for the proper use of many modern programming languages, even ones that don't explicitly contain let or lambda, such as Perl or Javascript.</p><p>Closures are one of those few curious concepts that are paradoxically difficult because they are so simple. Once a programmer becomes used to a complex solution to a problem, simple solutions to the same problem feel incomplete and uncomfortable. But, as we will soon see, closures can be a simpler, more direct solution to the problem of how to organise data and code than objects. Even more important than their simplicity, closures represent a better abstraction to use when constructing macros&mdash;the topic of this book.</p><p>The fact that we can build objects and classes with our closure primitives doesn't mean that object systems are useless to lisp programmers. Far from it. In fact, C<small>OMMON</small> L<small>ISP</small> includes one of the most powerful object systems ever devised: <i>CLOS</i>, the C<small>OMMON</small> L<small>ISP</small> Object System. Although I am very impressed with the flexibility and features of CLOS, I seldom find a need to use its more advanced features<a href=\"#\" onclick=\"toggle_note(1); return false\"><sup>1</sup></a><span id=\"note_1\" style=\"display:none\"> <sup><i>CLOS is so central to C<small>OMMON</small> L<small>ISP</small> that it is literally impossible to program in C<small>OMMON</small> L<small>ISP</small> without it.</i></sup> </span>, thanks to assignable value cells and good old lambda expressions.</p><p>While much of this book assumes a reasonable level of lisp skill, this chapter attempts to teach the theory and use of closures from the very basics as well as to provide a common terminology for closures that will be used throughout the rest of this book. This chapter also examines the efficiency implications of closures and considers how well modern compilers optimise them.</p>",
	sec_2: String() + "<h3 id=\"sec_2\">Environments and Extent</h3>\n<p>What Steele means by assignable value cells is an environment for storing pointers to data where the environment is subject to something called <i>indefinite extent</i>. This is a fancy way of saying that we can continue to refer to such an environment at any time in the future. Once we allocate this environment, it and its references are there to stay as long as we need them. Consider this C function:</p><p><pre class=\"lol_pre\">#include &lt;stdlib.h&gt;\n\nint *environment_with_indefinite_extent(int input) {\n  int *a = malloc(sizeof(int));\n  *a = input;\n  return a;\n}</pre></p><p>After we call this function and receive the pointer it returns, we can continue to refer to the allocated memory indefinitely. In C, new environments are created when invoking a function, but C programmers know to <b>malloc()</b> the required memory when returning it for use outside the function.</p><p>By contrast, the example below is flawed. C programmers consider <b>a</b> to be automatically collected when the function returns because the environment is allocated on the <i>stack</i>. In other words, according to lisp programmers, <b>a</b> is allocated with <i>temporary extent</i>.</p><p><pre class=\"lol_pre\">int *environment_with_temporary_extent(int input) {\n  int a = input;\n  return &amp;a;\n}</pre></p><p>The difference between C environments and lisp environments is that unless you explicitly tell lisp otherwise it always assumes you mean to use indefinite extent. In other words, lisp always assumes you mean to call <b>malloc()</b> as above. It can be argued that this is inherently less efficient than using temporary extent, but the benefits almost always exceed the marginal performance costs. What's more, lisp can often determine when data can safely be allocated on the stack and will do so automatically. You can even use <i>declarations</i> to tell lisp to do this explicitly. We will discuss declarations in more detail in <a href=\"chap7.html\">chapter 7, Macro Efficiency Topics</a>.</p><p>But because of lisp's dynamic nature, it doesn't have explicit pointer values or types like C. This can be confusing if you, as a C programmer, are used to casting pointers and values to indicate types. Lisp thinks about all this slightly differently. In lisp, a handy mantra is the following:</p><p><i>Variables don't have types. Only values have types.</i></p><p>Still, we have to return something to hold pointers. In lisp there are many data structures that can store pointers. One of the most favoured by lisp programmers is a simple structure: the <i>cons cell</i>. Each cons cell holds exactly two pointers, affectionately called car and cdr. When <b>environment-with-indefinite-extent</b> is invoked, a cons cell will be returned with the car pointing to whatever was passed as <b>input</b> and the cdr pointing to <b>nil</b>. And, most importantly, this cons cell (and with it the pointer to <b>input</b>) has indefinite extent so we can continue to refer to it as long as we need to:</p><p><pre class=\"lol_pre\">(defun environment-with-indefinite-extent (input)\n  (cons input nil))</pre></p><p>The efficiency disadvantages of indefinite extent are approaching irrelevance as the state of the art in lisp compilation technology improves. Environments and extent are closely related to closures and more will be said about them throughout this chapter.",
	sec_3: String() + "</p><h3 id=\"sec_3\">Lexical and Dynamic Scope</h3>\n<p>The technical term for where to consider a variable reference valid is <i>scope</i>. The most common type of scope in modern languages is called <i>lexical</i> scope. When a fragment of code is surrounded by the lexical binding of a variable, that variable is said to be in the lexical scope of the binding. The <b>let</b> form, which is one of the most common ways to create bindings, can introduce these lexically scoped variables:</p><p><pre class=\"lol_pre\">* (let ((x 2))\n    x)\n\n2</pre></p><p>The <b>x</b> inside the body of the <b>let</b> form was accessed through lexical scope. Similarly, arguments to functions defined by <b>lambda</b> or <b>defun</b> are also lexically bound variables inside the text of the function definition. Lexical variables are variables that can only be accessed by code appearing inside the context of, for instance, the above <b>let</b> form. Because lexical scoping is such an intuitive way to limit the scope of access to a variable, it can appear to be the only way. Are there any other possibilities for scoping?</p><p>As useful as the combination of indefinite extent and lexical scoping turns out to be, it has until recently not been used to its fullest extent in mainstream programming languages. The first implementation was by Steve Russell for Lisp 1.5<sup><small>[HISTORY-OF-LISP]</small></sup> and was subsequently designed directly into languages like Algol-60, Scheme, and C<small>OMMON</small> L<small>ISP</small>. Despite this long and fruitful history, the numerous advantages of lexical scoping are only slowly being taken up by many Blubs.</p><p>Although the scoping methods provided by C-like languages are limited, C programmers need to program across different environments too. To do so, they often use an imprecisely defined scoping known as <i>pointer scope</i>. Pointer scope is famous for its difficulty to debug, numerous security risks, and, somewhat artificially, its efficiency. The idea behind pointer scoping is to define a domain specific language for controlling the registers and memory of a Von Neumman machine similar to most modern CPUs<sup><small>[PAIP-PIX]</small></sup>, then to use this language to access and manipulate data-structures with fairly direct commands to the CPU running the program. Pointer scoping was necessary for performance reasons before decent lisp compilers were invented but is now regarded as a problem with, rather than a feature of, modern programming languages.</p><p>Even though lisp programmers seldom think in terms of pointers, the understanding of pointer scoping is very valuable in the construction of efficient lisp code. In <a href=\"chap7.html#sec_4\">section 7.4, Pointer Scope</a> we will investigate implementing pointer scoping for the rare cases where we need to instruct the compiler on specific code creation. But for now we only need discuss its mechanics. In C, we sometimes would like to access a variable defined outside the function we are writing:</p><p><pre class=\"lol_pre\">#include &lt;stdio.h&gt;\n\nvoid pointer_scope_test() {\n  int a;\n  scanf(\"%d\", &amp;a);\n}</pre></p><p>In the above function we use the C <b>&amp;</b> operator to give the actual address in memory of our local variable <b>a</b> to the <b>scanf</b> function so it knows where to write the data it scans. Lexical scoping in lisp forbids us from implementing this directly. In lisp, we would likely pass an anonymous function to a hypothetical lisp <b>scanf</b> function, allowing it to set our lexical variable <b>a</b> even though <b>scanf</b> is defined outside our lexical scope:</p><p><pre class=\"lol_pre\">(let (a)\n  (scanf \"%d\" (lambda (v) (setf a v))))</pre></p><p>Lexical scope is the enabling feature for closures. In fact, closures are so related to this concept of lexical scope that they are often referred to more specifically as <i>lexical closures</i> to distinguish them from other types of closures. Unless otherwise noted, all closures in this book are lexical.</p><p>In addition to lexical scope, C<small>OMMON</small> L<small>ISP</small> provides <i>dynamic scope</i>. This is lisp <i>slang</i> for the combination of temporary extent and global scope. Dynamic scoping is a type of scoping that is unique to lisp in that it offers a very different behaviour but shares an identical syntax with lexical scope. In C<small>OMMON</small> L<small>ISP</small> we deliberately choose to call attention to variables accessed with dynamic scope by calling them <i>special variables</i>. These special variables can be defined with <b>defvar</b>. Some programmers follow a convention of prefixing and postfixing special variable names with asterisks, like <b>*temp-special*</b>. This is called the <i>earmuff</i> convention. For reasons explained in <a href=\"chap3.html#sec_7\">section 3.7, Duality of Syntax</a>, this book does not use earmuffs so our special variable declarations look like this:</p><p><pre class=\"lol_pre\">(defvar temp-special)</pre></p><p>When defined like this, <b>temp-special</b> will be designated special<a href=\"#\" onclick=\"toggle_note(2); return false\"><sup>2</sup></a><span id=\"note_2\" style=\"display:none\"> <sup><i>We can also indicate the specialness of variables by using declarations to make them locally special.</i></sup> </span> but will not be initialised with a value. In this state, a special variable is said to be <i>unbound</i>. Only special variables can be unbound&mdash;lexical variables are always bound and thus always have values. Another way of thinking of this is that by default all symbols represent lexically unbound variables. Just as with lexical variables, we can assign a value to special variables with <b>setq</b> or <b>setf</b>. Some lisps, like Scheme, do not have dynamic scope. Others, like EuLisp<sup><small>[SMALL-PIECES-P46]</small></sup>, use different syntax for accessing lexical versus special variables. But in C<small>OMMON</small> L<small>ISP</small> the syntax is shared. Many lispers consider this a feature. Here we assign a value to our special variable <b>temp-special</b>:</p><p><pre class=\"lol_pre\">(setq temp-special 1)</pre></p><p>So far, this special variable doesn't seem that special. It seems to be just another variable, bound in some sort of global namespace. This is because we have only bound it once&mdash;its default special global binding. Special variables are most interesting when they are re-bound, or <i>shadowed</i>, by new environments. If we define a function that simply evaluates and returns <b>temp-special</b>:</p><p><pre class=\"lol_pre\">(defun temp-special-returner ()\n  temp-special)</pre></p><p>This function can be used to examine the value that lisp evaluates <b>temp-special</b> to be at the moment in time when it was called:</p><p><pre class=\"lol_pre\">* (temp-special-returner)\n\n1</pre></p><p>This is sometimes referred to as evaluating the form in a <i>null lexical environment</i>. The null lexical environment obviously doesn't contain any lexical bindings. Here the value of <b>temp-special</b> returned is that of its global special value, 1. But if we evaluate it in a non-null lexical environment&mdash;one that contains a binding for our special variable&mdash;the specialness of <b>temp-special</b> reveals itself<a href=\"#\" onclick=\"toggle_note(3); return false\"><sup>3</sup></a><span id=\"note_3\" style=\"display:none\"> <sup><i>Because we create a dynamic binding we are not actually creating a lexical environment. It just looks that way.</i></sup> </span>:</p><p><pre class=\"lol_pre\">* (let ((temp-special 2))\n    (temp-special-returner))\n\n2</pre></p><p>Notice that the value 2 was returned, meaning that the <b>temp-special</b> value was taken from our <b>let</b> environment, not its global special value. If this still does not seem interesting, see how this cannot be done in most other conventional programming languages as exemplified by this piece of Blub pseudo-code:</p><p><pre class=\"lol_pre\">int global_var = 0;\n\nfunction whatever() {\n  int global_var = 1;\n  do_stuff_that_uses_global_var();\n}\n\nfunction do_stuff_that_uses_global_var() {\n  // global_var is 0\n}</pre></p><p>While the memory locations or register assignments for lexical bindings are known at compile-time<a href=\"#\" onclick=\"toggle_note(4); return false\"><sup>4</sup></a><span id=\"note_4\" style=\"display:none\"> <sup><i>Sometimes lexical scoping is called \"static scoping\" for this reason.</i></sup> </span>, special variable bindings are determined at run-time&mdash;in a sense. Thanks to a clever trick, special variables aren't as inefficient as they seem. A special variable actually always does refer to the same location in memory. When you use <b>let</b> to bind a special variable, you are actually compiling in code that will store a copy of the variable, over-write the memory location with a new value, evaluate the forms in the let body, and, finally, restore the original value from the copy.</p><p>Special variables are perpetually associated with the symbol used to name them. The location in memory referred to by a special variable is called the <b>symbol-value</b> cell of a symbol. This is in direct contrast to lexical variables. Lexical variables are only indicated with symbols at compile-time. Because lexical variables can only be accessed from inside the lexical scope of their bindings, the compiler has no reason to even remember the symbols that were used to reference lexical variables so it will remove them from compiled code. We will stretch the truth of this statement in <a href=\"chap6.html#sec_7\">section 6.7, Pandoric Macros</a>.</p><p>Although C<small>OMMON</small> L<small>ISP</small> does offer the invaluable feature of dynamic scope, lexical variables are the most common. Dynamic scoping used to be a defining feature of lisp but has, since C<small>OMMON</small> L<small>ISP</small>, been almost completely replaced by lexical scope. Since lexical scoping enables things like lexical closures (which we examine shortly), as well as more effective compiler optimisations, the superseding of dynamic scope is mostly seen as a good thing. However, the designers of C<small>OMMON</small> L<small>ISP</small> have left us a very transparent window into the world of dynamic scoping, now acknowledged for what it really is: special.",
	sec_4: String() + "</p><h3 id=\"sec_4\">Let It Be Lambda</h3>\n<p><b>Let</b> is a lisp special form for creating an environment with names (bindings) initialised to the results of evaluating corresponding forms. These names are available to the code inside the <b>let</b> body while its forms are evaluated consecutively, returning the result of the final form. Although what <b>let</b> does is unambiguous, how it does it is deliberately left unspecified. What <b>let</b> does is separated from how it does it. Somehow, <b>let</b> needs to provide a data structure for storing pointers to values.</p><p>Cons cells are undeniably useful for holding pointers, as we saw above, but there are numerous structures that can be used. One of the best ways to store pointers in lisp is to let lisp take care of it for you with the <b>let</b> form. With <b>let</b> you only have to name (bind) these pointers and lisp will figure out how best to store them for you. Sometimes we can help the compiler make this more efficient by giving it extra bits of information in the form of declarations:</p><p><pre class=\"lol_pre\">(defun register-allocated-fixnum ()\n  (declare (optimize (speed 3) (safety 0)))\n  (let ((acc 0))\n    (loop for i from 1 to 100 do\n      (incf (the fixnum acc)\n            (the fixnum i)))\n    acc))</pre></p><p>For example, in <b>register-allocated-fixnum</b> we provide some hints to the compiler that allow it to sum the integers from 1 to 100 very efficiently. When compiled, this function will allocate the data in registers, eliminating the need for pointers altogether. Even though it seems we've asked lisp to create an indefinite extent environment to hold <b>acc</b> and <b>i</b>, a lisp compiler will be able to optimise this function by storing the values solely in CPU registers. The result might be this machine code:</p><p><pre class=\"lol_pre\">; 090CEB52:       31C9             XOR ECX, ECX\n;       54:       B804000000       MOV EAX, 4\n;       59:       EB05             JMP L1\n;       5B: L0:   01C1             ADD ECX, EAX\n;       5D:       83C004           ADD EAX, 4\n;       60: L1:   3D90010000       CMP EAX, 400\n;       65:       7EF4             JLE L0</pre></p><p>Notice that 4 represents 1 and 400 represents 100 because fixnums are shifted by two bits in compiled code. This has to do with <i>tagging</i>, a way to pretend that something is a pointer but actually store data inside it. Our lisp compiler's tagging scheme has the nice benefit that no shifting needs to occur to index word aligned memory<sup><small>[DESIGN-OF-CMUCL]</small></sup>. We'll get to know our lisp compiler better in <a href=\"chap7.html\">chapter 7, Macro Efficiency Topics</a>.</p><p>But if lisp determines that you might want to refer to this environment later on it will have to use something less transient than a register. A common structure for storing pointers in environments is an array. If each environment has an array and all the variable references enclosed in that environment are just references into this array, we have an efficient environment with potentially indefinite extent.</p><p>As mentioned above, <b>let</b> will return the evaluation of the last form in its body. This is common for many lisp special forms and macros, so common that this pattern is often referred to as an <i>implicit progn</i> due to the <b>progn</b> special form designed to do nothing but this<a href=\"#\" onclick=\"toggle_note(5); return false\"><sup>5</sup></a><span id=\"note_5\" style=\"display:none\"> <sup><i><b>Progn</b> is actually also useful for clustering forms to give them all top-level behaviour.</i></sup> </span>. Sometimes the most valuable thing to have a let form return is an anonymous function which takes advantage of the lexical environment supplied by the let form. To create these functions in lisp we use <i>lambda</i>.</p><p><i>Lambda</i> is a simple concept that can be intimidating because of its flexibility and importance. The lambda from lisp and scheme owes its roots to Alonzo Church's logic system but has evolved and adapted into its altogether own lisp specification. Lambda is a concise way to repeatably assign temporary names (bindings) to values for a specific lexical context and underlies lisp's concept of a function. A lisp function is very different from the mathematical function description that Church had in mind. This is because lambda has evolved as a powerful, practical tool at the hands of generations of lispers, stretching and extending it much further than early logicians could have foreseen.</p><p>Despite the reverence lisp programmers have for lambda, there is nothing inherently special about the notation. As we will see, lambda is just one of many possible ways to express this sort of variable naming. In particular, we will see that macros allow us to customise the renaming of variables in ways that are effectively impossible in other programming languages. But after exploring this, we will return to lambda and discover that it is very close to the optimal notation for expressing such naming. This is no accident. Church, as dated and irrelevant as he might seem to our modern programming environment, really was on to something. His mathematical notation, along with its numerous enhancements in the hands of generations of lisp professionals, has evolved into a flexible, general tool<a href=\"#\" onclick=\"toggle_note(6); return false\"><sup>6</sup></a><span id=\"note_6\" style=\"display:none\"> <sup><i>The classic example of a macro is an implementation of <b>let</b> as a lambda form. I will not bore you with that in this book.</i></sup> </span>.</p><p>Lambda is so useful that, like many of lisp's features, most modern languages are beginning to import the idea from lisp into their own systems. Some language designers feel that lambda is too lengthy, instead using <b>fn</b> or some other abbreviation. On the other hand, some regard lambda as a concept so fundamental that obscuring it with a lesser name is next to heresy. In this book, although we will describe and explore many variations on lambda, we happily call it lambda, just as generations of lisp programmers before us.</p><p>But what is lisp's lambda? First off, as with all names in lisp, lambda is a <i>symbol</i>. We can quote it, compare it, and store it in lists. Lambda only has a special meaning when it appears as the first element of a list. When it appears there, the list is referred to as a <i>lambda form</i> or as a <i>function designator</i>. But this form is not a function. This form is a list data structure that can be converted into a function using the <b>function</b> special form:</p><p><pre class=\"lol_pre\">* (function '(lambda (x) (+ 1 x)))\n\n#&lt;Interpreted Function&gt;</pre></p><p>C<small>OMMON</small> L<small>ISP</small> provides us a convenience shortcut for this with the #' (sharp-quote) read macro. Instead of writing <b>function</b> as above, for the same effect we can take advantage of this shortcut:</p><p><pre class=\"lol_pre\">* #'(lambda (x) (+ 1 x))\n\n#&lt;Interpreted Function&gt;</pre></p><p>As a further convenience feature, lambda is also defined as a macro that expands into a call to the function special form above. The C<small>OMMON</small> L<small>ISP</small> ANSI standard requires<sup><small>[ANSI-CL-ISO-COMPATIBILITY]</small></sup> a <b>lambda</b> macro defined like so:</p><p><pre class=\"lol_pre\">(defmacro lambda (&amp;whole form &amp;rest body)\n  (declare (ignore body))\n  `#',form)</pre></p><p>Ignore the ignore declaration for now<a href=\"#\" onclick=\"toggle_note(7); return false\"><sup>7</sup></a><span id=\"note_7\" style=\"display:none\"> <sup><i>A U-Language declaration.</i></sup> </span>. This macro is just a simple way to automatically apply the <b>function</b> special form to your function designators. This macro allows us to evaluate function designators to create functions because they are expanded into sharp-quoted forms:</p><p><pre class=\"lol_pre\">* (lambda (x) (+ 1 x))\n\n#&lt;Interpreted Function&gt;</pre></p><p>There are few good reasons to prefix your lambda forms with #' thanks to the <b>lambda</b> macro. Because this book makes no effort to support pre-ANSI C<small>OMMON</small> L<small>ISP</small> environments, backwards compatibility reasons are easily rejected. But what about stylistic objections? Paul Graham, in <i>ANSI C<small>OMMON</small> L<small>ISP</small></i><sup><small>[GRAHAM-ANSI-CL]</small></sup>, considers this macro, along with its brevity benefits, a \"specious sort of elegance at best\". Graham's objection seems to be that since you still need to sharp-quote functions referenced by symbols, the system seems asymmetric. However, I believe that not sharp-quoting lambda forms is actually a stylistic improvement because it highlights the asymmetry that exists in the second namespace specification. Using sharp-quote for symbols is for referring to the second namespace, whereas functions created by lambda forms are, of course, nameless.</p><p>Without even invoking the <b>lambda</b> macro, we can use lambda forms as the first argument in a function call. Just like when a symbol is found in this position and lisp assumes we are referencing the <b>symbol-function</b> cell of the symbol, if a lambda form is found, it is assumed to represent an anonymous function:</p><p><pre class=\"lol_pre\">* ((lambda (x) (+ 1 x)) 2)\n\n3</pre></p><p>But note that just as you can't call a function to dynamically return the symbol to be used in a regular function call, you can't call a function to return a lambda form in the function position. For both of these tasks, use either <b>funcall</b> or <b>apply</b>.</p><p>A benefit of lambda expressions that is largely foreign to functions in C and other languages is that lisp compilers can often optimise them out of existence completely. For example, although <b>compiler-test</b> looks like it applies an increment function to the number 2 and returns the result, a decent compiler will be smart enough to know that this function always returns the value 3 and will simply return that number directly, invoking no functions in the process. This is called <i>lambda folding</i>:</p><p><pre class=\"lol_pre\">(defun compiler-test ()\n  (funcall\n    (lambda (x) (+ 1 x))\n    2))</pre></p><p>An important efficiency observation is that a compiled lambda form is a constant form. This means that after your program is compiled, all references to that function are simply pointers to a chunk of machine code. This pointer can be returned from functions and embedded in new environments, all with no function creation overhead. The overhead was absorbed when the program was compiled. In other words, a function that returns another function will simply be a constant time pointer return function:</p><p><pre class=\"lol_pre\">(defun lambda-returner ()\n  (lambda (x) (+ 1 x)))</pre></p><p>This is in direct contrast to the <b>let</b> form, which is designed to create a new environment at run-time and as such is usually not a constant operation because of the garbage collection overhead implied by lexical closures, which are of indefinite extent.</p><p><pre class=\"lol_pre\">(defun let-over-lambda-returner ()\n  (let ((y 1))\n    (lambda (x)\n      (incf y x))))</pre></p><p>Every time <b>let-over-lambda-returner</b> is invoked, it must create a new environment, embed the constant pointer to the code represented by the lambda form into this new environment, then return the resulting <i>closure</i>. We can use <b>time</b> to see just how small this environment is:</p><p><pre class=\"lol_pre\">* (progn\n    (compile 'let-over-lambda-returner)\n    (time (let-over-lambda-returner)))\n\n; Evaluation took:\n;   ...\n;   24 bytes consed.\n;\n#&lt;Closure Over Function&gt;</pre></p><p>If you try to call compile on a closure, you will get an error saying you can't compile functions defined in non-null lexical environments<sup><small>[CLTL2-P677]</small></sup>. You can't compile closures, only the functions that create closures. When you compile a function that creates closures, the closures it creates will also be compiled<sup><small>[ON-LISP-P25]</small></sup>.</p><p>The use of a let enclosing a lambda above is so important that we will spend the remainder of this chapter discussing the pattern and variations on it.</p>", 
	sec_5: String() + "<h3 id=\"sec_5\">Let Over Lambda</h3>\n<p><i>Let over lambda</i> is a nickname given to a lexical closure. Let over lambda more closely mirrors the lisp code used to create closures than does most terminology. In a let over lambda scenario, the last form returned by a <b>let</b> statement is a <b>lambda</b> expression. It literally looks like <b>let</b> is sitting on top of <b>lambda</b>:</p><p><pre class=\"lol_pre\">* (let ((x 0))\n    (lambda () x))\n\n#&lt;Interpreted Function&gt;</pre></p><p>Recall that the <b>let</b> form returns the result of evaluating the last form inside its body, which is why evaluating this let over lambda form produced a function. However, there is something special about the last form in the <b>let</b>. It is a <b>lambda</b> form with <b>x</b> as a <i>free variable</i>. Lisp was smart enough to determine what <b>x</b> should refer to for this function: the <b>x</b> from the surrounding lexical environment created by the <b>let</b> form. And, because in lisp everything is of indefinite extent by default, the environment will be available for this function to use as long as it needs it.</p><p>So lexical scope is a tool for specifying exactly where references to a variable are valid, and exactly what the references refer to. A simple example of a closure is a <i>counter</i>, a closure that stores an integer in an environment and increments and returns this value upon every invocation. Here is how it is typically implemented, with a let over lambda:</p><p><pre class=\"lol_pre\">(let ((counter 0))\n  (lambda () (incf counter)))</pre></p><p>This closure will return 1 the first time it is called, 2 the subsequent time, and so on. One way of thinking about closures is that they are functions with <i>state</i>. These functions are not mathematical functions, but rather procedures, each with a little memory of its own. Sometimes data structures that bundle together code and data are called <i>objects</i>. An object is a collection of procedures and some associated state. Since objects are so closely related to closures, they can often be thought of as one and the same. A closure is like an object that has exactly one method: <b>funcall</b>. An object is like a closure that you can <b>funcall</b> in multiple ways.</p><p>Although closures are always a single function and its enclosing environment, the multiple methods, inner classes, and static variables of object systems all have their closure counterparts. One possible way to simulate multiple methods is to simply return multiple <b>lambda</b>s from inside the same lexical scope:</p><p><pre class=\"lol_pre\">(let ((counter 0))\n  (values\n    (lambda () (incf counter))\n    (lambda () (decf counter))))</pre></p><p>This <i>let over two lambdas</i> pattern will return two functions, both of which access the same enclosing counter variable. The first increments it and the second decrements it. There are many other ways to accomplish this. One of which, <b>dlambda</b>, is discussed in <a href=\"chap5.html#sec_7\">section 5.7, Dlambda</a>. For reasons that will be explained as we go along, the code in this book will structure all data using closures instead of objects. Hint: It has to do with macros.</p>", 
	sec_6: String() + "<h3 id=\"sec_6\">Lambda Over Let Over Lambda</h3>\n<p>In some object systems there is a sharp distinction between objects, collections of procedures with associated state, and classes, the data structures used to create objects. This distinction doesn't exist with closures. We saw examples of forms you can evaluate to create closures, most of them following the pattern let over lambda, but how can our program create these objects as needed?</p><p>The answer is profoundly simple. If we can evaluate them in the REPL, we can evaluate them inside a function too. What if we create a function whose sole purpose is to evaluate a let over lambda and return the result? Because we use <b>lambda</b> to represent functions, it would look something like this:</p><p><pre class=\"lol_pre\">(lambda ()\n  (let ((counter 0))\n    (lambda () (incf counter))))</pre></p><p>When the <i>lambda over let over lambda</i> is invoked, a new closure containing a counter binding will be created and returned. Remember that <b>lambda</b> expressions are constants: mere pointers to machine code. This expression is a simple bit of code that creates new environments to close over the inner <b>lambda</b> expression (which is itself a constant, compiled form), just as we were doing at the REPL.</p><p>With object systems, a piece of code that creates objects is called a class. But lambda over let over lambda is subtly different than the classes of many languages. While most languages require classes to be named, this pattern avoids naming altogether. Lambda over let over lambda forms can be called <i>anonymous classes</i>.</p><p>Although anonymous classes are often useful, we usually do name classes. The easiest way to give them names is to recognise that such classes are regular functions. How do we normally name functions? With the <b>defun</b> form, of course. After naming, the above anonymous class becomes:</p><p><pre class=\"lol_pre\">(defun counter-class ()\n  (let ((counter 0))\n    (lambda () (incf counter))))</pre></p><p>Where did the first <b>lambda</b> go? <b>Defun</b> supplies an <i>implicit lambda</i> around the forms in its body. When you write regular functions with <b>defun</b> they are still lambda forms underneath but this fact is hidden beneath the surface of the <b>defun</b> syntax.</p><p>Unfortunately, most lisp programming books don't provide realistic examples of closure usage, leaving readers with the inaccurate impression that closures are only good for toy examples like counters. Nothing could be further from the truth. Closures are the building blocks of lisp. Environments, the functions defined inside those environments, and macros like <b>defun</b> that make using them convenient, are all that are needed for modelling any problem. This book aims to stop beginning lisp programmers used to object-based languages from acting upon their gut instinct of reaching for systems like CLOS. While CLOS does have certain things to offer the professional lisp programmer, do not use it when a lambda will suffice.</p><p><fieldset><legend>BLOCK-SCANNER</legend><pre class=\"lol_code\">(defun block-scanner (trigger-string)\n  (let* ((trig (coerce trigger-string 'list))\n         (curr trig))\n    (lambda (data-string)\n      (let ((data (coerce data-string 'list)))\n        (dolist (c data)\n          (if curr\n            (setq curr\n                  (if (char= (car curr) c)\n                    (cdr curr) ; next char\n                    trig))))   ; start over \n        (not curr))))) ; return t if found</pre></fieldset></p><p>In order to motivate the use of closures, a realistic example is presented: <b>block-scanner</b>. The problem <b>block-scanner</b> solves is that for some forms of data transfer the data is delivered in groups (blocks) of uncertain sizes. These sizes are generally convenient for the underlying system but not for the application programmer, often being determined by things like operating system buffers, hard drive blocks, or network packets. Scanning a stream of data for a specific sequence requires more than just scanning each block as it comes in with a regular, stateless procedure. We need to keep state between the scanning of each block because it is possible that the sequence we are scanning for will be split between two (or more) blocks.</p><p>The most straightforward, natural way to implement this stored state in modern languages is with a closure. An initial sketch of a closure-based block scanner is given as <b>block-scanner</b>. Like all lisp development, creating closures is an iterative process. We might start off with code given in <b>block-scanner</b> and decide to improve its efficiency by avoiding coercion of strings to lists, or possibly improve the information gathered by counting the number of occurrences of the sequence.</p><p>Although <b>block-scanner</b> is an initial implementation waiting to be improved, it is still a good demonstration of the use of lambda over let over lambda. Here is a demonstration of its use, pretending to be some sort of communications tap watching out for a specific black-listed word, <i>jihad</i>:</p><p><pre class=\"lol_pre\">* (defvar scanner\n    (block-scanner \"jihad\"))\n\nSCANNER\n* (funcall scanner \"We will start \")\n\nNIL\n# (funcall scanner \"the ji\")\n\nNIL\n* (funcall scanner \"had tomorrow.\")\n\nT</pre></p>", 
	sec_7: String() + "<h3 id=\"sec_7\">Let Over Lambda Over Let Over Lambda</h3>\n<p>Users of object systems store values they want shared between all objects of a certain class into so-called <i>class variables</i> or <i>static variables</i><a href=\"#\" onclick=\"toggle_note(8); return false\"><sup>8</sup></a><span id=\"note_8\" style=\"display:none\"> <sup><i>The term static is one of the most overloaded programming language terms. Variables shared by all objects of a class are called static variables in languages like Java, which is distantly related to one of the meanings of static in C.</i></sup> </span>. In lisp, this concept of sharing state between closures is handled by environments in the same way that closures themselves store state. Since an environment is accessible indefinitely, as long as it is still possible to reference it, we are guaranteed that it will be available as long as is needed.</p><p>If we want to maintain a global direction for all counters, <b>up</b> to increment each closure's counter and <b>down</b> to decrement, then we might want to use a let over lambda over let over lambda pattern:</p><p><pre class=\"lol_pre\">(let ((direction 'up))\n  (defun toggle-counter-direction ()\n    (setq direction\n          (if (eq direction 'up)\n            'down\n            'up)))\n\n  (defun counter-class ()\n    (let ((counter 0))\n      (lambda ()\n        (if (eq direction 'up)\n          (incf counter)\n          (decf counter))))))</pre></p><p>In the above example, we have extended <b>counter-class</b> from the previous section. Now calling closures created with <b>counter-class</b> will either increment its counter binding or decrement it, depending on the value of the direction binding which is shared between all counters. Notice that we also take advantage of another <b>lambda</b> inside the direction environment by creating a function called <b>toggle-counter-direction</b> which changes the current direction for all counters.</p><p>While this combination of <b>let</b> and <b>lambda</b> is so useful that other languages have adopted it in the form of class or static variables, there exist other combinations of <b>let</b> and <b>lambda</b> that allow you to structure code and state in ways that don't have direct analogs in object systems<a href=\"#\" onclick=\"toggle_note(9); return false\"><sup>9</sup></a><span id=\"note_9\" style=\"display:none\"> <sup><i>But these analogs can sometimes be built on top of object systems.</i></sup> </span>. Object systems are a formalisation of a subset of let and lambda combinations, sometimes with gimmicks like <i>inheritance</i> bolted on<a href=\"#\" onclick=\"toggle_note(10); return false\"><sup>10</sup></a><span id=\"note_10\" style=\"display:none\"> <sup><i>Having macros is immeasurably more important than having inheritance.</i></sup> </span>. Because of this, lisp programmers often don't think in terms of classes and objects. Let and lambda are fundamental; objects and classes are derivatives. As Steele says, the \"object\" need not be a primitive notion in programming languages. Once assignable value cells and good old lambda expressions are available, object systems are, at best, occasionally useful abstractions and, at worst, special-case and redundant.</p>"
	}
};


// ------------- BEGIN SERVER CONFIGURATION ---------------
app.configure( function () {
  app.use( express.logger() );
  app.use( express.bodyParser() );
  app.use( express.methodOverride() );
  app.use( express.static( __dirname + '/public' ) ); 
  app.use( app.router );
});

app.get( '/', function ( request, response ) {
  response.redirect('mock_reader1.html');
  response.end();
});


app.get('/read/:cid(chp_[0-9]+)/:sid(sec_[0-9]+)', function(request,response) {
	console.log('yes');
	var chapter_id = request.params.cid,
		section_id = request.params.sid,
		section_data = book[chapter_id][section_id];
	console.log(section_id);
	console.log(section_data);
	response.contentType( 'json' );
	if (section_data) {
		response.send({
			data: section_data
		});	
	}
	response.end();

});

server.listen( 3000 );
console.log(
  'Express server listening on port %d in %s mode',
   server.address().port, app.settings.env
);


